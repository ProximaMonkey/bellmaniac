// Generated by LiveScript 1.4.0
(function(){
  var root, toPretty, slice$ = [].slice;
  root = typeof exports != 'undefined' && exports !== null ? exports : this;
  root.scope = [];
  root.id = function(d){
    return d && d[0];
  };
  root.take = function(index){
    return function(d){
      return d && d[index];
    };
  };
  root.keywords = ["set", "fix", "/", "+", "×", "∩", "-", "*", ":-"];
  root.tree = function(root, subtrees){
    return {
      $: 'Tree',
      root: root,
      subtrees: subtrees
    };
  };
  root.identifier = function(literal, kind){
    return {
      $: 'Identifier',
      literal: literal,
      kind: kind,
      ns: /^\?/.exec(literal) ? "*" : undefined
    };
  };
  root.operator = function(literal){
    return identifier(literal, 'operator');
  };
  root.genericIdentifier = function(literal){
    return identifier(literal, '?');
  };
  toPretty = function(t){
    if (t.subtrees.length > 0) {
      return t.root.literal + "{" + t.subtrees.map(toPretty).join(', ') + "}";
    } else {
      return t.root.literal + "";
    }
  };
  root.declareSet = function(literal){
    var x$;
    if (root.keywords.indexOf(literal) === -1) {
      x$ = identifier(literal, 'set');
      root.scope.push(x$);
      return x$;
    } else {
      return false;
    }
  };
  root.declareSets = function(head, tail){
    var v;
    return {
      kind: 'set',
      multiple: (function(){
        var i$, ref$, len$, x$, results$ = [];
        for (i$ = 0, len$ = (ref$ = [head].concat(slice$.call(tail))).length; i$ < len$; ++i$) {
          v = ref$[i$];
          x$ = identifier(v.root.literal, 'set');
          root.scope.push(x$);
          results$.push(x$);
        }
        return results$;
      }())
    };
  };
  root.declareSubsets = function(head, tail, superset){
    var v;
    if (!(superset.subtrees.length === 0 && superset.root.kind === 'set')) {
      throw new Error("expected a set type but found '" + toPretty(superset) + "'");
    }
    return {
      kind: 'set',
      multiple: (function(){
        var i$, ref$, len$, x$, results$ = [];
        for (i$ = 0, len$ = (ref$ = [head].concat(slice$.call(tail))).length; i$ < len$; ++i$) {
          v = ref$[i$];
          x$ = [identifier(v.root.literal, 'set'), identifier(superset.root.literal, 'set')];
          root.scope.push(x$);
          results$.push(x$);
        }
        return results$;
      }())
    };
  };
  root.typeVariable = function(literal){
    if (root.keywords.indexOf(literal) > -1) {
      return false;
    } else if (root.scope.some(function(set){
      var ref$;
      return set.literal === literal || ((ref$ = set[0]) != null ? ref$.literal : void 8) === literal;
    })) {
      return tree(identifier(literal, 'set'), []);
    } else {
      return tree(identifier(literal, "type variable"), []);
    }
  };
  root.variable = function(literal){
    if (!in$(literal, root.keywords) && !root.scope.some(function(it){
      return it.literal === literal;
    })) {
      return tree(identifier(literal, 'variable'), []);
    } else {
      return false;
    }
  };
  root.abstraction = function(par, body){
    return par && body && tree(genericIdentifier('↦'), [par, body]);
  };
  root.application = function(lhs, rhs){
    return lhs && rhs && tree(genericIdentifier('@'), [lhs, rhs]);
  };
  root.typeOperation = function(op, lhs, rhs){
    return op && lhs && rhs && tree(operator(op), [lhs, rhs]);
  };
  root.functionType = function(lhs, rhs){
    return lhs && rhs && tree(genericIdentifier('->'), [lhs, rhs]);
  };
  root.slashExpression = function(lhs, rhs){
    return lhs && rhs && tree(operator('/'), [lhs, rhs]);
  };
  root.fixedExpression = function(subj){
    return subj && tree(operator('fix'), [subj]);
  };
  root.cons = function(car, cdr){
    return application(application(variable('cons'), car), cdr);
  };
  function in$(x, xs){
    var i = -1, l = xs.length >>> 0;
    while (++i < l) if (x === xs[i]) return true;
    return false;
  }
}).call(this);
