// Generated by LiveScript 1.4.0
(function(){
  var spawn, assert, _, root, stripComments, readResponseBlocks;
  spawn = require('child_process').spawn;
  assert = require('assert');
  _ = require('lodash');
  root = typeof exports != 'undefined' && exports !== null ? exports : this;
  stripComments = function(input){
    return input.replace(/\s*\/\/.*$|\/\*[\s\S]*?\*\//mg, '');
  };
  root.splitTextToBlocks = function(input){
    var blocks, countLines;
    blocks = input.split(/(\n+)(?!\s)/).map(function(it){
      return {
        text: it
      };
    });
    countLines = function(text){
      return (text.match(/\n/g) || []).length;
    };
    _.reduce(blocks, function(x, y){
      y.line = x;
      return x + countLines(y.text);
    }, 1);
    return blocks.filter(function(it){
      return /\S/.exec(it.text);
    });
  };
  readResponseBlocks = function(output, parsedInputs){
    var i$, ref$, len$, blockIdx, block, outputBlock, err, x$, ref1$, ref2$, results$ = [];
    for (i$ = 0, len$ = (ref$ = output.split(/\n\n+(?=\S)/)).length; i$ < len$; ++i$) {
      blockIdx = i$;
      block = ref$[i$];
      try {
        outputBlock = JSON.parse(block);
        if (outputBlock.error) {
          throw outputBlock;
        }
        results$.push({
          value: outputBlock
        });
      } catch (e$) {
        err = e$;
        x$ = parsedInputs[blockIdx];
        err.line = (ref1$ = (ref2$ = x$.check) != null
          ? ref2$
          : x$.tactic) != null ? ref1$.line : void 8;
        throw err;
      }
    }
    return results$;
  };
  root.bellmaniaParse = function(input, success, error){
    var blocks, buffer, output, jar, mode, toStream, stream, err;
    blocks = splitTextToBlocks(stripComments(input.text));
    try {
      buffer = [];
      output = {
        fromNearley: [],
        fromJar: []
      };
      jar = spawn("java", ['-jar', 'lib/bell.jar', '-']);
      jar.stdout.setEncoding('utf-8');
      jar.stdout.on('data', function(data){
        buffer.push(data);
      });
      jar.stdout.on('end', function(){
        var err;
        try {
          output.fromJar = readResponseBlocks(buffer.join(""), output.fromNearley);
          success(output);
        } catch (e$) {
          err = e$;
          error(err, output);
        }
      });
      jar.stderr.on('data', function(data){
        error(data);
      });
      root.scope = [];
      mode = "check";
      output.fromNearley = _.chain(blocks).map(function(block){
        var p, parsed, results, x$, ref$, err;
        p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);
        try {
          parsed = p.feed(block.text);
          results = _.compact(parsed.results);
          if (results.length === 0) {
            throw {
              message: "No possible parse of input found."
            };
          }
          assert(results.length === 1, JSON.stringify(results) + " is not a unique parse.");
          x$ = (ref$ = results[0], ref$.mode = mode, ref$.line = block.line, ref$);
          if (x$.setMode != null) {
            mode = x$.setMode;
          }
          return x$;
        } catch (e$) {
          err = e$;
          err.line = block.line;
          throw err;
        }
      }).filter(function(block){
        return block.kind !== 'set' && !(block.setMode != null);
      }).map(function(block){
        var ref$;
        return ref$ = {}, ref$[block.mode] = block, ref$.scope = window.scope, ref$;
      }).value();
      toStream = function(stream){
        var i$, ref$, len$, parsedBlock, term, tacticBlock;
        if (input.isTactic) {
          for (i$ = 0, len$ = (ref$ = output.fromNearley).length; i$ < len$; ++i$) {
            parsedBlock = ref$[i$];
            if (input.termJson.root.literal !== 'program') {
              term = tree(identifier('program', '?'), [input.termJson]);
            } else {
              term = input.termJson;
            }
            tacticBlock = {
              tactic: parsedBlock.check,
              term: term
            };
            stream.write(JSON.stringify(tacticBlock));
            stream.write("\n\n");
          }
        } else {
          for (i$ = 0, len$ = (ref$ = output.fromNearley).length; i$ < len$; ++i$) {
            parsedBlock = ref$[i$];
            stream.write(JSON.stringify(parsedBlock));
            stream.write("\n\n");
          }
        }
        return stream.end();
      };
      fs.writeFileSync("/tmp/synopsis.txt", input.text);
      stream = fs.createWriteStream("/tmp/synopsis.json");
      stream.once('open', function(){
        return toStream(stream);
      });
      jar.stdin.setEncoding('utf-8');
      return toStream(jar.stdin);
    } catch (e$) {
      err = e$;
      return error(err);
    }
  };
}).call(this);
