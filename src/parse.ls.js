// Generated by LiveScript 1.4.0
(function(){
  var spawn, assert, _, root, stripComments, splitTextToBlocks;
  spawn = require('child_process').spawn;
  assert = require('assert');
  _ = require('lodash');
  root = typeof exports != 'undefined' && exports !== null ? exports : this;
  stripComments = function(input){
    return input.replace(/\s*\/\/.*$|\/\*[\s\S]*?\*\//mg, '');
  };
  splitTextToBlocks = function(input){
    var blocks, countLines;
    blocks = input.split(/(\n+)(?!\s)/).map(function(it){
      return {
        text: it
      };
    });
    countLines = function(text){
      return (text.match(/\n/g) || []).length;
    };
    _.reduce(blocks, function(x, y){
      y.line = x;
      return x + countLines(y.text);
    }, 1);
    return blocks.filter(function(it){
      return /\S/.exec(it.text);
    });
  };
  root.bellmaniaParse = function(input, success, error){
    var blocks, buffer, output, jar, toStream, stream, err;
    blocks = splitTextToBlocks(stripComments(input.text));
    try {
      buffer = [];
      output = {
        fromNearley: [],
        fromJar: []
      };
      jar = spawn("java", ['-jar', 'lib/bell.jar', '-']);
      jar.stdout.setEncoding('utf-8');
      jar.stdout.on('data', function(data){
        buffer.push(data);
      });
      jar.stdout.on('end', function(){
        var i$, ref$, len$, block, outputBlock, err;
        try {
          for (i$ = 0, len$ = (ref$ = buffer.join("").split(/\n\n+(?=\S)/)).length; i$ < len$; ++i$) {
            block = ref$[i$];
            outputBlock = JSON.parse(block);
            if (outputBlock.error) {
              throw outputBlock;
            }
            output.fromJar.push({
              value: outputBlock
            });
          }
          success(output);
        } catch (e$) {
          err = e$;
          error(err);
        }
      });
      jar.stderr.on('data', function(data){
        error(data);
      });
      root.scope = [];
      output.fromNearley = _.chain(blocks).map(function(block){
        var p, parsed, results, err;
        p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);
        try {
          parsed = p.feed(block.text);
          results = _.compact(parsed.results);
          if (results.length === 0) {
            throw {
              message: "No possible parse of input found."
            };
          }
          assert(results.length === 1, JSON.stringify(results) + " is not a unique parse.");
          return results[0];
        } catch (e$) {
          err = e$;
          throw {
            line: block.line,
            err: err
          };
        }
      }).filter(function(block){
        return block.kind !== 'set';
      }).map(function(block){
        return {
          check: block,
          scope: window.scope
        };
      }).value();
      toStream = function(stream){
        var i$, ref$, len$, parsedBlock, term, tacticBlock;
        if (input.isTactic) {
          for (i$ = 0, len$ = (ref$ = output.fromNearley).length; i$ < len$; ++i$) {
            parsedBlock = ref$[i$];
            if (input.termJson.root.literal !== 'program') {
              term = tree(identifier('program', 'variable'), [input.termJson]);
            } else {
              term = input.termJson;
            }
            tacticBlock = {
              tactic: parsedBlock.check,
              term: term
            };
            stream.write(JSON.stringify(tacticBlock));
            stream.write("\n\n");
          }
        } else {
          for (i$ = 0, len$ = (ref$ = output.fromNearley).length; i$ < len$; ++i$) {
            parsedBlock = ref$[i$];
            stream.write(JSON.stringify(parsedBlock));
            stream.write("\n\n");
          }
        }
        return stream.end();
      };
      fs.writeFileSync("/tmp/synopsis.txt", input);
      stream = fs.createWriteStream("/tmp/synopsis.json");
      stream.once('open', function(){
        return toStream(stream);
      });
      jar.stdin.setEncoding('utf-8');
      return toStream(jar.stdin);
    } catch (e$) {
      err = e$;
      err.message = JSON.stringify(err);
      return error(err);
    }
  };
}).call(this);
