// Generated by LiveScript 1.4.0
(function(){
  var spawn, _, LET_RE, assert, x$;
  spawn = require('child_process').spawn;
  _ = require('lodash');
  LET_RE = /^\s*([\s\S]+?)\s+=\s+([\s\S]+?)\s*$/;
  assert = require('assert');
  x$ = angular.module('app', ['RecursionHelper', 'ui.codemirror']);
  x$.controller("Ctrl", function($scope){
    $scope.code = localStorage.getItem('codeMirrorContents') || "a b";
    $scope.parsed = {};
    $scope.output = {};
    $scope.data = [];
    $scope.editor = initEditor(function(cm){});
    $scope.splitTextToBlocks = function(input){
      return input.split(/\n+(?!\s)/).filter((function(it){
        return /\S/.exec(it);
      }));
    };
    $scope.parseAndDisplay = function(){
      var blocks, buffer, jar, toStream, stream, err;
      $scope.parsed = [];
      $scope.output = [];
      $scope.data = [];
      blocks = $scope.splitTextToBlocks($scope.code);
      try {
        buffer = [];
        jar = spawn("java", ['-jar', 'lib/bell.jar', '-']);
        jar.stdout.setEncoding('utf-8');
        jar.stdout.on('data', function(data){
          buffer.push(data);
        });
        jar.stdout.on('end', function(){
          var outputFromJar, i$, ref$, len$, block, output, err;
          outputFromJar = [];
          for (i$ = 0, len$ = (ref$ = buffer.join("").split(/\n\n+(?=\S)/)).length; i$ < len$; ++i$) {
            block = ref$[i$];
            try {
              output = JSON.parse(block);
              $scope.output.push(output);
              $scope.data.push({
                value: output
              });
            } catch (e$) {
              err = e$;
              console.error(err.stack);
              $scope.data.push({
                error: err.toString()
              });
            }
          }
          $scope.$apply();
        });
        jar.stderr.on('data', function(data){
          console.error('Java error: ' + data);
        });
        window.scope = [];
        $scope.parsed = _.chain(blocks).map(function(block){
          var p, parsed, results;
          p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);
          parsed = p.feed(block);
          console.debug(parsed.results);
          results = _.filter(parsed.results, function(r){
            return r;
          });
          assert(results.length === 1, JSON.stringify(results) + " is not a unique parse.");
          return results[0];
        }).filter(function(block){
          return block.root.kind !== 'set';
        }).map(function(block){
          return {
            check: block
          };
        }).value();
        toStream = function(stream){
          var i$, ref$, len$, parsedBlock;
          for (i$ = 0, len$ = (ref$ = $scope.parsed).length; i$ < len$; ++i$) {
            parsedBlock = ref$[i$];
            stream.write(JSON.stringify(parsedBlock));
            stream.write("\n\n");
          }
          return stream.end();
        };
        fs.writeFileSync("/tmp/synopsis.txt", $scope.code);
        stream = fs.createWriteStream("/tmp/synopsis.json");
        stream.once('open', function(){
          return toStream(stream);
        });
        jar.stdin.setEncoding('utf-8');
        toStream(jar.stdin);
      } catch (e$) {
        err = e$;
        console.error(err);
        $scope.parsed = err;
      }
    };
  });
  x$.filter("collapse", function(){
    var lead;
    lead = function(it){
      return it.match(/^\s*/)[0].length;
    };
    return function(input, indent){
      return ("" + input).split(/\n/).filter(function(it){
        return lead(it) < indent;
      }).join("\n");
    };
  });
  x$.directive("display", function(RecursionHelper){
    return {
      restrict: 'E',
      scope: {
        o: '=o'
      },
      template: $('#display').html(),
      compile: function(element){
        return RecursionHelper.compile(element);
      }
    };
  });
  x$.directive("compute", function(){
    return {
      scope: {},
      transclude: 'element',
      link: function(scope, element, attrs, ctrl, $transclude){
        var expr, mo, lhs, rhs;
        expr = attrs['let'];
        mo = expr != null ? expr.match(LET_RE) : void 8;
        if (mo == null) {
          throw Error("invalid let '" + expr + "'");
        }
        lhs = mo[1];
        rhs = mo[2];
        return $transclude(function(clone, scope){
          scope.$watch(rhs, function(v){
            return scope[lhs] = v;
          }, true);
          return $(clone).insertAfter(element);
        });
      }
    };
  });
  x$.filter("isString", function(){
    return _.isString;
  });
  x$.filter("display", function(){
    return function(input){
      var last, text, x$, i$, ref$, len$, ref1$, ref2$, u, v, mark, x, y, cls;
      if (_.isString(input)) {
        return input;
      } else if (input.tape != null) {
        last = 0;
        text = input.tape.text;
        x$ = [];
        for (i$ = 0, len$ = (ref$ = input.tape.markup).length; i$ < len$; ++i$) {
          ref1$ = ref$[i$], ref2$ = ref1$[0], u = ref2$[0], v = ref2$[1], mark = ref1$[1];
          x = text.substring(last, u);
          y = text.substring(u, v);
          cls = ['mark'].concat(mark.type != null
            ? ['tip']
            : []);
          last = v;
          if (x.length) {
            x$.push([x]);
          }
          if (y.length) {
            x$.push([y, cls, mark.type]);
          }
        }
        x = text.substring(last);
        if (x.length) {
          x$.push([x]);
        }
        return x$;
      } else {
        return [JSON.stringify(input)];
      }
    };
  });
}).call(this);
