// Generated by LiveScript 1.4.0
(function(){
  var spawn, _, LET_RE, assert, x$;
  spawn = require('child_process').spawn;
  _ = require('lodash');
  LET_RE = /^\s*([\s\S]+?)\s+=\s+([\s\S]+?)\s*$/;
  assert = require('assert');
  x$ = angular.module('app', ['RecursionHelper', 'ui.codemirror']);
  x$.controller("Ctrl", function($scope){
    var hintWords, autoWords, i$, ref$, len$, i, charCode, letter, findCurWord, findSuffixWord, hintReplace, autoReplace;
    $scope.code = localStorage.getItem('codeMirrorContents') || "a b";
    $scope.editorOptions = {
      mode: "scheme",
      matchBrackets: {
        bracketRegex: /[(){}[\]⟨⟩]/,
        bracketMatching: {
          "(": ")>",
          ")": "(<",
          "[": "]>",
          "]": "[<",
          "{": "}>",
          "}": "{<",
          "⟨": "⟩>",
          "⟩": "⟨<"
        }
      },
      theme: "material"
    };
    $scope.parsed = {};
    $scope.output = {};
    $scope.data = [];
    hintWords = [
      {
        text: "α",
        displayText: "\\alpha"
      }, {
        text: "β",
        displayText: "\\beta"
      }, {
        text: "γ",
        displayText: "\\gamma"
      }, {
        text: "δ",
        displayText: "\\delta"
      }, {
        text: "ε",
        displayText: "\\epsilon"
      }, {
        text: "ζ",
        displayText: "\\zeta"
      }, {
        text: "η",
        displayText: "\\eta"
      }, {
        text: "θ",
        displayText: "\\theta"
      }, {
        text: "ι",
        displayText: "\\iota"
      }, {
        text: "κ",
        displayText: "\\kappa"
      }, {
        text: "λ",
        displayText: "\\lambda"
      }, {
        text: "μ",
        displayText: "\\mu"
      }, {
        text: "ν",
        displayText: "\\nu"
      }, {
        text: "ξ",
        displayText: "\\xi"
      }, {
        text: "ο",
        displayText: "\\omicron"
      }, {
        text: "π",
        displayText: "\\pi"
      }, {
        text: "ρ",
        displayText: "\\rho"
      }, {
        text: "σ",
        displayText: "\\sigma"
      }, {
        text: "τ",
        displayText: "\\tau"
      }, {
        text: "υ",
        displayText: "\\upsilon"
      }, {
        text: "φ",
        displayText: "\\phi"
      }, {
        text: "χ",
        displayText: "\\chi"
      }, {
        text: "ψ",
        displayText: "\\psi"
      }, {
        text: "ω",
        displayText: "\\omega"
      }, {
        text: "×",
        displayText: "\\times"
      }, {
        text: "∩",
        displayText: "\\cap"
      }
    ];
    autoWords = [
      {
        text: "↦",
        displayText: "|->"
      }, {
        text: "\u27E8",
        displayText: "\\<"
      }, {
        text: "\u27E9",
        displayText: "\\>"
      }, {
        text: "×",
        displayText: "\\*"
      }
    ];
    for (i$ = 0, len$ = (ref$ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]).length; i$ < len$; ++i$) {
      i = ref$[i$];
      charCode = 0x2080 + i;
      autoWords.push({
        text: String.fromCharCode(charCode),
        displayText: "_" + i
      });
    }
    for (i$ = 0, len$ = (ref$ = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"]).length; i$ < len$; ++i$) {
      letter = ref$[i$];
      charCode = 0xdd30 + letter.charCodeAt(0) - 0x41;
      autoWords.push({
        text: "\ud83c" + String.fromCharCode(charCode),
        displayText: "[" + letter + "]"
      });
      autoWords.push({
        text: "\ud83c" + String.fromCharCode(charCode) + "\u0332",
        displayText: "[" + letter + "_]"
      });
    }
    findCurWord = function(editor, delimiters){
      var whitespace, cur, curLine, ref$, start, end, curWord;
      whitespace = /\s/;
      cur = editor.getCursor();
      curLine = editor.getLine(cur.line);
      ref$ = [cur.ch - 1, cur.ch], start = ref$[0], end = ref$[1];
      while (start >= 0 && !delimiters.test(curLine.charAt(start)) && !whitespace.test(curLine.charAt(start - 1))) {
        start -= 1;
      }
      curWord = start !== end ? curLine.slice(start, end) : "";
      return {
        word: curWord,
        start: start,
        end: end
      };
    };
    findSuffixWord = function(editor, words){
      var cur, curLine, matches, ref$, start, end, i, c;
      cur = editor.getCursor();
      curLine = editor.getLine(cur.line);
      matches = [];
      ref$ = [cur.ch - 1, cur.ch, 1], start = ref$[0], end = ref$[1], i = ref$[2];
      while (start >= 0 && words.length > 0) {
        c = curLine.charAt(start);
        words = words.filter(fn$);
        matches = matches.concat(words.filter(fn1$).map(fn2$));
        start -= 1;
        i += 1;
      }
      return matches;
      function fn$(it){
        var ref$;
        return (ref$ = it.displayText)[ref$.length - i] === c;
      }
      function fn1$(it){
        return it.displayText.length === i;
      }
      function fn2$(it){
        return {
          word: it,
          start: start,
          end: end
        };
      }
    };
    hintReplace = function(editor){
      var curPos, curWord, cur, filteredWords;
      curPos = findCurWord(editor, /\\/);
      curWord = curPos.word;
      cur = editor.getCursor();
      filteredWords = hintWords.filter(function(w){
        return curWord.length > 0 && w.displayText.indexOf(curWord) === 0;
      });
      return {
        list: filteredWords,
        from: CodeMirror.Pos(cur.line, curPos.start),
        to: CodeMirror.Pos(cur.line, curPos.end)
      };
    };
    autoReplace = function(editor){
      var cur, filteredWords, curPos;
      cur = editor.getCursor();
      filteredWords = findSuffixWord(editor, autoWords);
      if (filteredWords.length > 0) {
        curPos = filteredWords[0];
        return editor.replaceRange(curPos.word.text, CodeMirror.Pos(cur.line, curPos.start), CodeMirror.Pos(cur.line, curPos.end));
      }
    };
    $scope.codemirrorLoaded = function(editor){
      CodeMirror.registerHelper("hint", "anyword", hintReplace);
      CodeMirror.commands.autocomplete = function(cm){
        return cm.showHint({
          hint: CodeMirror.hint.anyword,
          completeSingle: false
        });
      };
      return editor.on('change', function(editor, changeObj){
        var text, valid;
        localStorage.setItem('codeMirrorContents', editor.getValue());
        text = changeObj.text[0];
        valid = text != null && text.length === 1 && ((text >= "a" && text <= "z") || (text >= "A" && text <= "Z") || (text >= "0" && text <= "9") || (text === ';' || text === '=' || text === ',' || text === '-' || text === '.' || text === '/' || text === '`' || text === '[' || text === '\\' || text === ']' || text === '\'' || text === '<' || text === '>' || text === '*'));
        if (valid) {
          autoReplace(editor);
          CodeMirror.commands.autocomplete(editor);
        }
      });
    };
    $scope.splitTextToBlocks = function(input){
      return input.split(/\n+(?!\s)/).filter((function(it){
        return /\S/.exec(it);
      }));
    };
    $scope.parseAndDisplay = function(){
      var blocks, buffer, jar, toStream, stream, err;
      $scope.parsed = [];
      $scope.output = [];
      $scope.data = [];
      blocks = $scope.splitTextToBlocks($scope.code);
      try {
        buffer = [];
        jar = spawn("java", ['-jar', 'lib/bell.jar', '-']);
        jar.stdout.setEncoding('utf-8');
        jar.stdout.on('data', function(data){
          buffer.push(data);
        });
        jar.stdout.on('end', function(){
          var outputFromJar, i$, ref$, len$, block, output, err;
          outputFromJar = [];
          for (i$ = 0, len$ = (ref$ = buffer.join("").split(/\n\n+(?=\S)/)).length; i$ < len$; ++i$) {
            block = ref$[i$];
            try {
              output = JSON.parse(block);
              $scope.output.push(output);
              $scope.data.push({
                value: output
              });
            } catch (e$) {
              err = e$;
              console.error(err.stack);
              $scope.data.push({
                error: err.toString()
              });
            }
          }
          $scope.$apply();
        });
        jar.stderr.on('data', function(data){
          console.error('Java error: ' + data);
        });
        window.scope = [];
        $scope.parsed = _.chain(blocks).map(function(block){
          var p, parsed, results;
          p = new nearley.Parser(grammar.ParserRules, grammar.ParserStart);
          parsed = p.feed(block);
          console.debug(parsed.results);
          results = _.filter(parsed.results, function(r){
            return r;
          });
          assert(results.length === 1, JSON.stringify(results) + " is not a unique parse.");
          return results[0];
        }).filter(function(block){
          return block.root.kind !== 'set';
        }).map(function(block){
          return {
            check: block
          };
        }).value();
        toStream = function(stream){
          var i$, ref$, len$, parsedBlock;
          for (i$ = 0, len$ = (ref$ = $scope.parsed).length; i$ < len$; ++i$) {
            parsedBlock = ref$[i$];
            stream.write(JSON.stringify(parsedBlock));
            stream.write("\n\n");
          }
          return stream.end();
        };
        fs.writeFileSync("/tmp/synopsis.txt", $scope.code);
        stream = fs.createWriteStream("/tmp/synopsis.json");
        stream.once('open', function(){
          return toStream(stream);
        });
        jar.stdin.setEncoding('utf-8');
        toStream(jar.stdin);
      } catch (e$) {
        err = e$;
        console.error(err);
        $scope.parsed = err;
      }
    };
  });
  x$.filter("collapse", function(){
    var lead;
    lead = function(it){
      return it.match(/^\s*/)[0].length;
    };
    return function(input, indent){
      return ("" + input).split(/\n/).filter(function(it){
        return lead(it) < indent;
      }).join("\n");
    };
  });
  x$.directive("display", function(RecursionHelper){
    return {
      restrict: 'E',
      scope: {
        o: '=o'
      },
      template: $('#display').html(),
      compile: function(element){
        return RecursionHelper.compile(element);
      }
    };
  });
  x$.directive("compute", function(){
    return {
      scope: {},
      transclude: 'element',
      link: function(scope, element, attrs, ctrl, $transclude){
        var expr, mo, lhs, rhs;
        expr = attrs['let'];
        mo = expr != null ? expr.match(LET_RE) : void 8;
        if (mo == null) {
          throw Error("invalid let '" + expr + "'");
        }
        lhs = mo[1];
        rhs = mo[2];
        return $transclude(function(clone, scope){
          scope.$watch(rhs, function(v){
            return scope[lhs] = v;
          }, true);
          return $(clone).insertAfter(element);
        });
      }
    };
  });
  x$.filter("isString", function(){
    return _.isString;
  });
  x$.filter("display", function(){
    return function(input){
      var last, text, x$, i$, ref$, len$, ref1$, ref2$, u, v, mark, x, y, cls;
      if (_.isString(input)) {
        return input;
      } else if (input.tape != null) {
        last = 0;
        text = input.tape.text;
        x$ = [];
        for (i$ = 0, len$ = (ref$ = input.tape.markup).length; i$ < len$; ++i$) {
          ref1$ = ref$[i$], ref2$ = ref1$[0], u = ref2$[0], v = ref2$[1], mark = ref1$[1];
          x = text.substring(last, u);
          y = text.substring(u, v);
          cls = ['mark'].concat(mark.type != null
            ? ['tip']
            : []);
          last = v;
          if (x.length) {
            x$.push([x]);
          }
          if (y.length) {
            x$.push([y, cls, mark.type]);
          }
        }
        x = text.substring(last);
        if (x.length) {
          x$.push([x]);
        }
        return x$;
      } else {
        return [JSON.stringify(input)];
      }
    };
  });
}).call(this);
