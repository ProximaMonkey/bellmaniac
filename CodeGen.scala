// Turn functions into NumPy tables
// Treat first 'dom' arguments as indexes into tables
// Expects input programs to be flattened
class NumPython(val dom: Int) extends PythonPrinter with Logger {
  assert (dom > 0)
  def prelude = """# autogenerated by bellmaniac
import sys
plus = min
zero = sys.maxint
DIM = 128
MIN = 0
MAX = 1000
from numpy import *
""" 
 
  private def print(l: List[Expr]): String = l.map(print(_)).mkString(", ")  
  private def indent(tabs: Int = dom+1) = (1 to tabs).map(_ => "  ").mkString("")

  import Transform.{transform, visit}
  
  // create T value
  val T = Var("T", dom)

  // current algorithm
  private var scope: Algorithm = _ 
  private var offv: List[Var] = _

  // all computations
  private var all: List[Computation] = _  
  
  def inputs = all.collect { case i: Input => i }
  def algorithms = all.collect { case a: Algorithm => a }

  // Use lookup tables instead of function applications 
  override def print(e: Expr) = e match {
    case App(v: Var, args) => print(v) + "[" + print(args) + "]"
    case _: OpVar => error("should be unreachable")
    case v: Var if v.arity > 0 =>
      if (inputs.exists(_.v == v) || scope.args.contains(v) || v.name.startsWith("T"))
        v.name
      else
        error("can only pass tables as parameters: " + v)    
    case _ => super.print(e)
  }

  // Write to T at offset off by invoking v with rest
  case class Write(v: Var, T: Var, off: List[Expr], rest: List[Expr], deps: List[Write]) {
    assert (v.arity == off.size + rest.size, "must match arity")
    assert (off.size == dom && T.arity == dom)

    override def toString = v.name + "("  + print(T :: off ::: rest) + ")"

    def all: List[Write] =
      deps.flatMap(_.all) ::: this :: Nil

    def stmts: List[String] = all.map(_.toString)

    // same up to renaming of all Ts and this.off
    def same(that: Write): Boolean =
      this.v == that.v &&
      (this.rest zip that.rest).forall {
        case (e1, e2) =>
          e1 == e2 ||
          ((this.deps.find(_.T == e1), that.deps.find(_.T == e2)) match {
            case (Some(w1), Some(w2)) if w1.off == w2.off =>
              w1.same(w2)              
            case _ => false
          })
      }

    def replace(implicit that: Write): Write = {
      deps.find { case w => w.same(that) } match {
        case Some(w) => // replace and repeat
          // offset corrections 
          val offsets = that.off zip w.off map Minus.tupled;
          
          copy(deps = deps.filter(_ != w),
               rest = transform(App(v, off ::: rest)) {
                  case App(v, args) if args.contains(w.T) => 
                    // add offsets according to position of w.T
                    val a = algorithms.find(_.v == v).get
                    // find additions
                    var add: Map[Var, Expr] = Map()
                    for ((formal, actual) <- a.args zip args;
                         if actual == w.T;
                         (o, i) <- offsets.zipWithIndex)
                       add = add + (Var(formal.name + "_" + i) -> o)
                    // add them
                    App(v, for ((formal, actual) <- a.args zip args) yield {
                        if (actual == w.T)
                          that.T
                        else if (add.contains(formal))
                          Linear.make(actual + add(formal)).expr
                        else 
                          actual
                    })
                  case v: Var if v == w.T =>
                    error("must appear as a parameter in App")
                } match {
                  case App(_, args) => args.drop(dom)
                  case _ => ???
                }
          ).replace
        case None => // recurse
          copy(deps = deps.map(_.replace))
      }
    }
 }

  object Write {
    // top-level write
    def make(app: App): Write =
      make(app, T, offv zip scope.args.take(dom) map Plus.tupled)

    // off is offsets for T (where write should happen)
    // outputs list of write with last corresponding to this "app"
    // each child T is used only once in the parent
    def make(app: App, T: Var, off: List[Expr]): Write = app match {
      case App(v: Var, args) =>
        val offsets = 
          for ((o, a) <- off zip args.take(dom))
            yield Linear.make(o - a)
             
        var deps: List[Write] = Nil 

        // recurse on dependency OpVars
        val rest = for (arg <- args.drop(dom)) yield transform(arg) {
          case OpVar(v, args, exprs) =>
            assert(v.isInstanceOf[Var], "must be flattened")
            assert(exprs.startsWith(args), "must be fully linearized")
            assert(args.size == dom, "must match dom")            
            val T1 = T.fresh
            // todo: extract offsets from the opvar
            deps = make(App(v, exprs), T1, args) :: deps
            T1
        }
        
        Write(v, T, offsets.map(_.expr), rest, deps.reverse) 
    }
  }

 
  
  // use partitions in other partitions writes
  def reuse(writes: List[Write]) = {
    var deps: List[(Int, Int)] = Nil

    def replaceAll(writes: List[Write]) = 
      for ((w1,i) <- writes.zipWithIndex) yield {
        var out = w1
        for ((w2,j) <- writes.zipWithIndex if i != j) {          
          val next = out.replace(w2)
          if (out != next) {        
            out = next
            deps = (j, i) :: deps
          }
        }
        out            
      }

    var result: List[Write] = writes
    var prev: List[Write] = Nil
    while (result != prev) {
      prev = result
      result = replaceAll(result)
    }

    // permute according to deps
    def order(g: List[Int]): List[Int] = g match {
      case Nil => Nil
      case _ =>
        // find node without incoming edges
        g.find { case i => ! deps.exists(_._2 == i) } match {
          case Some(i) =>
            // remove from graph and recurse
            deps = deps.filter(_._1 != i)
            i :: order(g.filter(_ != i))
          case _ => error("loop detected")
        }
    }    

    order(0 to (writes.size - 1) toList).map(result(_))
  }

  // TODO: unsound
  // reuse memory tables in a write sequence 
  def overwrite(w: Write): Write = w match {
    case Write(v, t, off, rest, List(w1)) => 
      // must use only one temporary table once
      val t1 = w1.T
      if (! w1.off.forall(_ == Const(0)))
        error("must have 0-based tables")

      // must write where it reads from
      var off1: List[Expr] = Nil

      // find where it's used
      val rest1 = transform(App(v, off ::: rest)) {
        case App(v, args) if args.contains(t1) => 
          val a = algorithms.find(_.v == v).get
          
          // find formal argument for t1
          val formal = (a.args zip args).filter(_._2 == t1).map(_._1) match {
            case f :: Nil => f
            case _ => error("must have exactly one argument " + t1)
          }

          // find read signatures for a
          val fc = memory(a).read.filter(_.v == formal).map(_.c) match {
            case fc :: Nil => fc.map(_.s(a.args zip args))
            case _ => error("must have exactly one read vector " + t1)
          }

          // read at off1 from invocation point
          off1 = (0 to (dom-1)).map(i => 
            Linear.make(off(i) + args(i) - fc(i)).expr).toList

          // correcte offsets to use t instead of t1:
          var add = {for (i <- (0 to (dom - 1)))
            yield (Var(formal.name + "_" + i), off1(i))
          }.toMap

          // reuse this t in place of t1
          App(v, a.args zip args map {
            case (f, a) if f == formal => t
            case (f, a) if add.contains(f) => Linear.make(a + add(f)).expr
            case (_, a) => a
          })
        case v: Var if v == t1 =>
          error("must appear as a parameter in App")
      } match {
        case a: App => a.args.drop(dom)
        case _ => error("unexpected")
      }

      Write(v, t, off, rest1, List(overwrite(w1.copy(T = t, off = off1))))      
    case _ => w 
  }

  override def print(c: Computation) = c match {
    case Input(v) =>
      print(v) + " = " + {
        if (v.arity == 0) 
          "DIM" 
        else 
          "random.randint(MIN, MAX, size=(" + 
          (1 to v.arity).map(_ => "DIM").mkString(", ") + "))"
      }
    case a @ Algorithm(v, args, pre, e) =>        
      this.scope = a
      this.offv = args.take(dom).map { case Var(n, i) => Var("o" + n, i) }
      val loop = new LoopConstruct(a)

      "def " + v.name + "(" + print(T :: offv ::: args.drop(dom)) + "):\n" + {
        e match {
          case Cond(cases, Havoc) if cases.forall(_._2.isInstanceOf[App]) =>
            // SPLIT PROGRAM
            // compute with write sequences
            cases match {
              case (minp, mine: App) :: splits =>
                val (preds, es) = splits.unzip
                val apps = es.map {
                  case app: App => app
                  case _ => error("expected an app here")
                }
                // double check that splits are coming from the tactic
                for (p1 <- preds; p2 <- preds; if p1 != p2)
                  assert(SMT.prove((pre and p1) implies (! p2)))

                // reuse and overwrite
                val writes = reuse(apps.map(Write.make(_))).map(overwrite(_))
                
                "  if " + print(minp) + ":\n    " + 
                Write.make(mine).stmts.mkString("\n    ") + 
                "\n    return\n  " + {
                  (for (w1 <- writes;
                        w <- w1.all if w.T != T;
                        a <- algorithms if a.v == w.v)
                    yield print(w.T) + " = " + memory(a).alloc) :::
                  (for (w <- writes; stmt <- "# partition" :: w.stmts)
                    yield stmt)
              }.mkString("\n  ")
              case _ => ???
            }

          case _ =>
            // ABSTRACT SPEC PROGRAM
            // compute with the loop construct
            val (lvars, lbounds, lmap) = loop.generate

            // must be self-recursive for this to work
            def makeTs(e: Expr): Expr = transform(e) {
              case App(v, args) if a.v == v =>
                if (args.drop(dom) == a.args.drop(dom))
                  App(T, args.take(dom).map(makeTs) zip offv map { case (a, o) => a + o })
                else
                  error("self-recursion must project to same value")
            }
 
            {for (((lv, Range(l, h)), i) <- lvars zip lbounds zipWithIndex) 
              yield indent(i+1) + "for "+print(lv)+" in xrange("+print(l)+","+print(h)+"):\n"
            }.mkString("") + 
            {for ((l,i) <- lmap zipWithIndex) 
              yield indent() + args(i)+" = "+lmap(i)+"\n"
            }.mkString("") +
            indent() + "assert " + print(pre) + "\n" +   
            indent() + print(makeTs(App(v, args))) + " = " + print(makeTs(e))
        }
      }
  }
 
  override def print(p: List[Computation], out: java.io.PrintStream) {
    this.all = p
    super.print(p, out)
  }

  // Generate loop construct for an algorithm
  // Additional references:
  //    polyhedral model on wiki
  //    Omega library tutorials (e.g. SUIF)

  case class Rotation(flips: List[Boolean]) {  
    def apply(a: List[Expr]) = a zip flips map { 
      case (x, false) => x
      case (x, true) => Const(0) - x
    }
    def inverse = this
  }
  object Rotation {
    def all(d: Int): Iterator[Rotation] =   
      if (d == 0)
        List(Rotation(Nil)).iterator
      else
        (all(d-1) map { case Rotation(flips) => Rotation(false :: flips) }) ++
        (all(d-1) map { case Rotation(flips) => Rotation(true :: flips) })
  }

  case class Vector(path: Pred, v: Var, c: List[Expr])

  class LoopConstruct(a: Algorithm) extends Logger {
    val pre = a.pre
    val c = a.args.take(dom)
    
    // find all recursion references
    def vectors = {
      var out: List[Vector] = Nil
      transform(a) {
        case (path, locals, App(v, vargs)) =>
          if (v == a.v)
            out = Vector(path, a.v, vargs.take(dom)) :: out
          else if (! locals.contains(v) && ! inputs.exists(_.v == v))
            error("unexpected: " + v + " in " + a.v)
          Havoc
      }
      out
    }

    // domination order
    def LE(a: List[Expr], b: List[Expr]) = 
      a zip b map { case (x, y) => x <= y} reduce(And)
    
    // find domination order orientation
    def orient(vs: List[Vector]): Rotation = {
      for (r <- Rotation.all(dom))
        if (vs.forall { case Vector(p, _, v) => SMT.prove(p implies LE(r(v), r(c))) })
          return r
      error("can't orient in domination order")    
    }
    implicit def int2rat(n: Int) = new Rational(n, 1)
    implicit def int2expr(n: Int) = Const(n)
    implicit def int2linear(n: Int) = Linear.make(Map(), new Rational(n, 1))

    // solve for max expression
    def MAX(p: List[Expr], pred: Pred): Expr = p match {
      case Nil => ???
      case e :: Nil => e
      case e :: p1 =>
        val e1 = MAX(p1, pred)
        if (SMT.prove(pred implies e1 <= e))
          e
        else if (SMT.prove(pred implies e <= e1))
          e1
        else 
          error("can't find max of " + p + " under " + pred)        
    }

    // solve for min expression
    def MIN(p: List[Expr], pred: Pred): Expr = p match {
      case Nil => ???
      case e :: Nil => e
      case e :: p1 =>
        val e1 = MIN(p1, pred)
        if (SMT.prove(pred implies e <= e1))
          e
        else if (SMT.prove(pred implies e1 <= e))
          e1
        else 
          error("can't find min of " + p + " under " + pred)        
    }

    // Infer range constraints from linear constraints in predicate
    def inferBounds(p: List[Var], pred: Pred, 
      use: Boolean = true, transitive: Boolean = false): Option[List[Range]] = {
      var eqs = Linear.equations(pred)

      // compute transitive equations by eliminating one variable at a time
      if (transitive) 
        eqs = eqs ::: {
          for (v <- p;
            e1 <- eqs if e1.proj(v) > 0;
            e2 <- eqs if e2.proj(v) < 0) yield 
            e1 * e2.proj(v) * (-1) + e2 * e1.proj(v)         
          }
      

      // free variables (allowed to appear in result range)
      var free = Vars(pred) -- p
      
      var out: List[Range] = Nil
      for (v <- p) {       
        // find constraints only contains "free" vars and having "v"
        val bounds = eqs.filter { case eq => eq.has(v) && eq.vars.subsetOf(free + v) }
      
        // upper and lower bound expressions
        val lower = bounds.filter(_.proj(v) > 0).map { 
          case eq => 0 - (eq.drop(v) / eq.proj(v)) }.map(_.expr)
        val upper = bounds.filter(_.proj(v) < 0).map { 
          case eq => 1 - (eq.drop(v) / eq.proj(v)) }.map(_.expr)

        if (lower.size == 0 || upper.size == 0)
          return None

        // use previous variables in generating subsequent range bound
        if (use)
          free = free + v

        out = Range(MAX(lower, pred), MIN(upper, pred)) :: out
      }

      return Some(out.reverse)
    }


    // generate looping construct for first "dom" parameters of "a"
    // returns (list of iteration variables, list of their ranges, assignment to actual variables)
    def generate: (List[Var], List[Range], List[Expr]) = {
      // orient dependency vectors by flipping +/- coordinates so that they point
      // into lower-left corner
      val r = orient(vectors)

      // find iteration order and bounds
      // create fresh variables: c1 = r(c)
      val c1 = c.map { case Var(n, i) => Var(n +"0", i) }
      
      // formulate pre in terms of c1
      val exprs = r.inverse(c1)
      val pre1 = pre.s(c zip exprs)

      // try to order variables so that we can solve them one by one
      for (p <- c1.permutations) 
        inferBounds(p, pre1) match {
          case Some(ranges) => return (p, ranges, exprs)
          case _ =>
        }
     
      error("can't infer bounds: " + pre1)
    }
  }

  // Specifies read/write ranges 
  // (reads are applications of arguments under path conditions for given x in DOM)
  // (writes are bounds on DOM)
  // In particular, we can write into tables used in read as long as it's same x
  class MemorySpec(a: Algorithm) {
    // table dimensions (range from 0 to Expr)
    def write: List[Expr] = new LoopConstruct(a).inferBounds(a.args.take(dom), a.pre, false, true) match {
      case Some(ranges) =>
        for (Range(l, h) <- ranges) yield {
          if (! SMT.prove(a.pre implies l >= Const(0)))
            error("can't allocate memory with possibly negative index")
          h
        }
      case None => 
        error("can't infer memory allocation bounds")
    }

    def alloc = "zeros((" + print(write) + "), int)"
    
    def read: List[Vector] = {
      var out: List[Vector] = Nil      
      transform(a) {
        case (path, _, App(v: Var, vargs)) if a.args.contains(v) && v.arity == dom =>
          out = Vector(path, v, vargs) :: out
          Havoc
        case (_, _, App(v, _)) if v == a.v =>
          // TODO: block recursive passes of arguments, need to think about why it's ok
          Havoc
        case (_, _, v) if a.args.contains(v) && v.arity == dom =>
          println(a)
          error(s"can't infer memory spec if an argument function $v is passed in a call in ${a.v}")
      }
      out
    }
  }

  // use specification memory spec for an algorithm
  def memory(a: Algorithm): MemorySpec = a.expr match {
    case Cond((_, App(v, _)) :: _, Havoc) => // split?
      memory(algorithms.find(_.v == v).get)
    case _ => new MemorySpec(a)  
  }
}
