\section{Automated Proofs}

\newcommand\limplies{\rightarrow}

This section describes the encoding of proof obligations in first-order logic,
and the ways by which type information is used in discharging them.

Each base type is associated with a sort. The qualifiers are naturally encoded
as predicate symbols with appropriate sorts. In the following paragraphs, we
use a type and its associated sort interchangebly, and the meaning should be clear
from the context.

Each free variable and each node in the formula syntax tree are assigned two
symbols: a function symbol representing the values, and a predicate symbol
representing the support, that is, the set of tuples for which there is a mapping.
For example, a variable $f : J\to\R$ will be assigned a function $f^1: J\to\R$
and a predicate $|f|: J\to\B$. The superscript indictes the function's arity,
and the vertical bars indicate the support.

For refinement-typed symbols, the first-order symbols are still defined in terms
of the shape, and an assumption concerning the support is created. For example,
for $g: (J\cap P)\to\R$, the symbols $g^1:J\to\R$, $|g|:J\to\B$ are defined,
and the assumption $\forall \alpha:J.~|g|(\alpha)\limplies P(\alpha)$.

Assumptions are similarly created for nodes of the syntax tree of the formula to
be verified. We define the \newterm{enclosure} of a node to be the ordered set of
all the variables bound by ancestor abstraction nodes ($v\mapsto\ldots$). Since
the interpretation of the node depends on the values of these variables, it is
``skolemized'', i.e., its type is prefixed by the types of enclosing variables.
For example, if $e:\T$, then inside the term $(v:\S)\mapsto e$ it would be treated as
type $\S\to\T$.

When a function is being used as an argument in an application term (first-class functions), 
we take its arrow type $\T\to\S$ and create a corresponding \newterm{faux type} $F_{\T\to\S}$,
and an operator $@ : F_{\T\to\S}\to\T\to\S$, with the \newterm{extensionality axiom} ---
\begin{equation}
\forall \alpha\alpha'.~ \big(\forall\beta.~ @(\alpha,\beta)=@(\alpha',\beta)\big)\limplies \alpha=\alpha'
\label{automated:extensionality}
\end{equation}

And for each such function symbol $f^k:\T\to\S$ used as argument, create its 
\newterm{reflection} $f^0:F_{\T\to\S}$ defined by
\begin{equation}
\forall \overline\alpha.~~@(f^0,\overline\alpha)=f^k(\overline\alpha)
\label{automated:reflection}
\end{equation}
