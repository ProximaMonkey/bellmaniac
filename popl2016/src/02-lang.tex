\section{A Unified Language}

\newcommand\semp[1]{[\![{#1}]\!]}
\newcommand\fix{\operatorname{fix}}

Bellmania uses the same language for specifications and for programs.  Its core is simply-typed
$\lambda$-calculus with universally quantified type variables (polymorphic types).

We write abstraction terms as $(v:\T)\mapsto e$, where $\T$ is the type of the argument $v$ and $e$ is
the body. Curried functions $(v_1:\T_1)\mapsto (v_2:\T_2) \mapsto \cdots \mapsto (v_n:\T_n) \mapsto e$ are abbreviated 
as $(v_1:\T_1)\cdots(v_n:\T_n)\mapsto e$.

The semantics differ slightly from that of traditional functional languages: arrow types $\T_1\to\T_2$
are interpreted as {\bf mappings} from values of type $\T_1$ to values of type $\T_2$. Algebraically,
interpretations of types, $\semp{\T_1}$, $\semp{\T_2}$, are sets, and interpretations of arrow-typed terms,
$f : \T_1\to\T_2$, are {\bf partial functions} --- $\semp{f} : \semp{\T_1}\rightharpoonup\semp{\T_2}$.
This implies that a term $t : \T$ may evaluate to an \newterm{undefined} value, $\semp{t}=\bot_\T$
(We would shorten it to $\semp{t}=\bot$ when the type is either insignificant or understood from the context).
For simplicity, we shall identify $\bot_{\T_1\to\T_2}$ with the empty mapping $(v:\T_1)\mapsto\bot_{\T_2}$.

\subsection{Liquid Types}

The core is augmented with predicate abstraction in the form of logically quantified data types 
(Liquid Types~\cite{PLDI08/Rondon}). These are refinement types restricted via a set of abstraction predicates,
called \newterm{qualifiers}, which are defined over the base types.
Some qualifiers are built-in, and more can defined by the user. To keep the syntax simple, we somewhat
limit the use of qualifiers, allowing only the following forms:

\begin{itemize}
  \item $\{v:\T ~|~ P(v)\}$, abbreviated as $\T\cap P$. When the signature of $P$ is known (which is
  almost always), it is enough to write $P$.
  \item $\{v:\T ~|~ P(v)\land Q(v)\}$, abbreviated as $\T\cap P\cap Q$, or just $P\cap Q$. This extends
  to any number of conjuncts of the same form.
  \item $x : \T_2 \to \{v:\T_2 ~|~ R(x,v)\} \to \T_3$, abbreviated as $\big((\T_1\times\T_2)\cap R\big)\to\T_3$.
  Note that the first parameter to $R$ must be the preceding argument. This extends to quantifiers of
  any arity. Also note that the language does not define tuple types; hence there is no distinction
  between curried and uncurried function types.
\end{itemize}

The type refinement operators $\cap$ and $\times$ may be composed to create conjunctions of qualifiers,
as long as their argument sets are either disjoint or contained, but not overlapping;
for example, \[x:\{v:\T_1~|~P(v)\}\to \{v:\T_2~|~Q(v)\land R(x,v)\}\to\T_3\] can be written as
$\big((P\times Q)\cap R\big)\to\T_3$, but \[x:\T_1\to y:\{v:\T_2~|~R(x,v)\} \to \{v:\T_3~|~R(y,v)\}\to\T_4\]
cannot be represented by this restricted fragment.

As with any refinement type system, we define the \newterm{shape} of a type $\T$ to be the raw type
obtained from it by removing all qualifiers.

\subsection{Typing Rules}
\label{lang:typing rules}

\newcommand\powerset[1]{\mathbf{P}({#1})}

We define a Bellmania program to be well-typed iff its \newterm{raw form}, obtained by replacing all types by
their shapes, is well-typed. This gives a simple characteristic of type safety without the need to
explictly write any new typing rules. It also means that for $f:\T_1\to\T_2$, $x:T_3$, then $f\,x:\T_2$ whenever
$\T_1$ and $\T_3$ have the same shape. This is much more permissive than the original Liquid Types,
and requires some explanation.

Considering a (partial) function $\T\to\S$ to be a set of pairs of elements $\langle x,y\rangle$ 
from its domain $\T$ and range $\S$, respectively, it is clear to see that any function of type $\T_1\to\S_1$,
such that $\semp{\T_1}\subseteq\semp{\T}$, $\semp{\S_1}\subseteq\semp{\S}$, 
is \emph{also} a function of type $\T\to\S$, since $\semp{\T_1}\times\semp{\S_1}\subseteq\semp{\T}\times\semp{\S}$.
%and therefore $\powerset{\semp{\T_1}\times\semp{\S_1}} \subseteq \powerset{\semp{\T}\times\semp{\S}}$.
If we define subtyping as inclusion of the domains, i.e. $\T_1 <:\T$ whenever $\semp{\T_1}\subseteq\semp{\T}$,
this translates into:
%
\[\T_1<:\T ~\land~ \S_1<:\S ~~\Rightarrow~~ (\T_1\to\S_1) <: (\T\to\S)\]

In this case, the type constructor $\to$ is {\bf covariant} in both arguments.\footnote{This is different from classical view, and holds in this case because we interpret functions as \emph{mappings}.}
With this in mind, a function $g:(\T\to\S)\to \S_2$ can be called with an argument $a: \T_1\to\S_1$,
by regular subtyping rules, and $g\,a : \S_2$.

When the argument's type is not a subtype, but has the same shape as that of the expected type,
it is \newterm{coereced} to the required type by restricting the values to the desired proper subset.
%
\[\mbox{For }h:\T\to\S \qquad \semp{h\,a} ~=~ \semp{h}\big(\semp{a} :: \T\big)\]

Where $::$ is defined as follows:
\begin{itemize}
  \item For scalar (non-arrow) type $\T$, \[x :: \T ~=~ \begin{cases}x & \mbox{if }x\in\semp{\T} \\ \bot & \mbox{if }x\not\in\semp{\T}\end{cases}\]
  \item $f :: \T\to\S ~=~ x\mapsto \big(f\,(x :: \T)\big) :: \S$
\end{itemize}

\subsection{Operators}

\newcommand\applt{\textrm{{\scriptsize\,}\guillemotright{\scriptsize\,}}}

We define the following intrinsic operators:

\begin{itemize}
  \item Fixed point operator $\fix f$, with the denotational semantics
    \[\semp{\fix f} ~=~ \sigma x.~ (\semp f\,x=x)\]
  we assume that recurrences given in specifications are well-defined, 
  such that $\semp f$ has a single fixed point.
  In other words, we ignore nonterminating computations.
  \item Slash operator $/$,
  \[\begin{array}{ll}
      \mbox{For base type $\S$, $x,y:\S$} & x/y = \begin{cases}x & \mbox{if }x\neq\bot \\ y & \mbox{if }x=\bot\end{cases} \\
      \mbox{For $f,g:\T_1\to\T_2$} & f/g = (v:\T_1)\mapsto (f\,v)/(g\,v)
    \end{array}\]
  \item Cast operator $t :: \T$, as described in \Cref{lang:typing rules}.
\end{itemize}

For the purpose of Hindley-Milner type checking, these operators behave like polymorphic
constants of types ${\fix} : (\T\to\T)\to\T$, ${/} : \T\to\T\to\T$ and $(::\T) : \mathrm{shape}[\T]\to\mathrm{shape}[\T]$.
They also have type refinement rules as shown in \Cref{lang:type refinement for operators}.

\begin{figure*}
\[
\begin{array}{ll}
  \displaystyle
  \frac{e=\fix e_1 \quad \Gamma\vdash e:\T, e_1:\T_1\to\T_2}
       {\Gamma\vdash e: \T\sqcap\T_2} &
  \frac{e=e_1/e_2 \quad \Gamma\vdash e:\T, e_1:\T_1, e_2:\T_2}
       {\begin{array}{@{}l@{}l@{}}\Gamma\vdash{} & e_1:\T_1\sqcap\T \\ & e_2:\T_2\sqcap\T\end{array}}
\end{array}
\]
\caption{\label{lang:type refinement for operators}}
\end{figure*}

\todo{typing rules for operators}

We also adopt some syntactic sugar to make complex terms more managable:

\begin{itemize}
  \item $x \applt f ~=~ f\,x$ for application from the left.
  \item $t\big|_{\square}$ abbreviates $t::\square\to\T$, where $\T$ is a fresh type variable
    to be inferred (see \Cref{lang:type inf}). As a special case, $\big|$ can also be applied
    to scalar (non-arrow) expressions by supplying a Boolean condition,
    interpreted as a (nullary) qualifier:
    \[x\big|_{C} ~=~ x :: (\T\cap C) ~=~ \begin{cases}x & \mbox{if }C \\ \bot & \mbox{if }\lnot C\end{cases}\]
\end{itemize}

\subsection{Type Inference}
\label{lang:type inf}

Base types are inferred normally as in a classical Hindley-Milner type system.
Qualifiers are also inferred by defining a type intersection operator $\sqcap$ that
takes two types of the same shape $\T_1$, $\T_2$ and returns a type with a conjunction of all the qualifiers
occuring in either $\T_1$ or $\T_2$. The operator is defined in terms of the corresponding liquid types.
\begin{itemize}
  \item If $\T_1=\{v:\T ~|~ \varphi_1\}$ and $\T_2=\{v:\T ~|~ \varphi_2\}$,
	\[\T_1\sqcap\T_2 ~=~ \{v:\T ~|~ \varphi_1\land\varphi_2\}\]
  \item If $\T_1=x:\S_1\to\S_2$, $\T_2=x:\S_3\to\S_4$ (named arguments are normalized so that $\T_1$ and $\T_2$ use the same names),
    \[\T_1\sqcap\T_2 ~=~ x:(\S_1\sqcap\S_3)\to(\S_2\sqcap\S_4)\]
\end{itemize}

We then define the \newterm{type refinement} steps for $e$ a sub-term:
\begin{itemize}
  \item If $e=e_1\,e_2$, where $\Gamma \vdash e:\T_0, e_1:\T_1, e_2:\T_2\to\S_2$,
    \[\begin{array}{l@{}l}
        \Gamma ~\vdash~ & e:\T_0\sqcap\S_2, \\ & e_1:\T_1\sqcap\T_2, \\ & e_2:(\T_0\to\T_1)\sqcap(\T_2\to\S_2)
      \end{array}\]
  \item If $e=(v::\T)\mapsto e_1$, where $\Gamma\vdash e:\T_0\to\S_0$ and $\Gamma,v:\T\sqcap\T_0\vdash e_1:\T_1$,
    \[\begin{array}{l}\Gamma ~\vdash~ e:(\T_0\to\S_0)\sqcap(\T\to\T_1)\\
      \Gamma,v:\T\sqcap\T_0 ~\vdash~ e_1:\T_1\sqcap\S_0 \end{array}\]
  \item If $e=v$ (a leaf) and $\Gamma,v:\T_1\vdash e:\T_0$,
    \[\Gamma,v:\T_1 ~\vdash~ e:\T_0\sqcap\T_1\]
  \item If $e=e_1/e_2$ and $\Gamma\vdash e:\T_0, e_1:\T_1, e_2:\T_2$,
    \[\Gamma ~\vdash~ e_1:T_1\sqcap\T_0, e_2:T_2\sqcap\T_0\]
\end{itemize}

These rules are applied continuously until a fixed point is reached.
The resulting types are eventually converted back to a canonical form that uses $\cap$ and $\times$.
Qualifiers that cannot be expressed in this form are discarded.

Note that two syntactically identical terms in different sub-trees may be assigned
different types by this method. This is a desirable property, as (some) context information
gets encoded in the type that way.

\subsection{Primitives}

The standard library contains some common primitives:

\begin{itemize}
  \item $\R$, a type for real numbers; $\N$ for natural numbers; $\B$ for Boolean true/false.
  \item ${=} : \T\to\T\to\B$, always interpreted as equality.
  \item ${+}, {-} : \T\to\T\to\T$, polymorphic binary operators.
  \item ${<} : \T\to\T\to\B$, a polymorphic order relation.
  \item $\min, \max, \Sigma : (\T\to\S)\to\S$, reduction operators
    on ordered/unordered collections. The collection is represented by a mapping $f : \T\to\S$,
    so that e.g. \[\semp{\min f} = \min \{\semp{f}\,v \;|\; v\in\semp{A}, \semp{f}\,v\neq\bot\}\]
    The collections are expected to be finite.
\end{itemize}

\subsection{Example \hrulefill}

The specification of the Simplified Gap (\eqref{intro:gap spec} from \Cref{intro}) will be written as
%
\begin{equation}
  \renewcommand\arraystretch{1.5}
  \begin{array}{@{}l@{}l@{}l@{}}
    \lspan3{w :: ((J\times J)\cap{<})\to\R} \\
    \lspan3{w' :: ((K\times K)\cap{<})\to\R} \\
    G ~=~ \fix \theta\,i\,j\mapsto{}
      & \lspan2{0\big|_{i=0\land j=0} ~\Big/~ w'_{0j}\big|_{i=0} ~\Big/~ w_{i0}\big|_{j=0} ~\Big/~} \\
      & \min~\langle~ & \min p\mapsto\theta_{pj}+w_{pi}, \\
      & & \min q\mapsto\theta_{iq}+w'_{qj} ~\rangle
  \end{array}
  \label{lang:gap spec}
\end{equation}

\medskip
We are using $f_{xy}$
as a more readable alternative typography for $f\,x\,y$,
where $f$ is a function symbol and $x$, $y$ are its arguments.

\medskip
\hrule
