\section{A Unified Language}

\newcommand\semp[1]{[\![{#1}]\!]}
\newcommand\fix{\operatorname{fix}}

Bellmania uses the same language for specifications and for programs.  Its core is simply-typed
$\lambda$-calculus with universally quantified type variables (polymorphic types).

We write abstraction terms as $(v:\T)\mapsto e$, where $\T$ is the type of the argument $v$ and $e$ is
the body. Curried functions $(v_1:\T_1)\mapsto (v_2:\T_2) \mapsto \cdots \mapsto (v_n:\T_n) \mapsto e$ are abbreviated 
as $(v_1:\T_1)\cdots(v_n:\T_n)\mapsto e$.

The semantics differ slightly from that of traditional functional languages: arrow types $\T_1\to\T_2$
are interpreted as {\bf mappings} from values of type $\T_1$ to values of type $\T_2$. Algebraically,
interpretations of types, $\semp{\T_1}$, $\semp{\T_2}$, are sets, and interpretations of arrow-typed terms,
$f : \T_1\to\T_2$, are {\bf partial functions} --- $\semp{f} : \semp{T_1}\rightharpoonup\semp{T_2}$.
This implies that a term $t : \T$ may evaluate to an \newterm{undefined} value, $\semp{t}=\bot_\T$
(We would shorten it to $\semp{t}=\bot$ when the type is either insignificant or understood from the context).
For simplicity, we shall identify $\bot_{\T_1\to\T_2}$ with the empty mapping $(v:\T_1)\mapsto\bot_{\T_2}$.

\subsection{Liquid Types}

The core is augmented with predicate abstraction in the form of logically quantified data types 
(Liquid Types~\citneeded{}). These are refinement types restricted via a set of abstraction predicates,
called \newterm{qualifiers}, which are defined over the base types.
Some qualifiers are built-in, and more can defined by the user. To keep the syntax simple, we somewhat
limit the use of qualifiers, allowing only the following forms:

\begin{itemize}
  \item $\{v:\T ~|~ P(v)\}$, abbreviated as $\T\cap P$. When the signature of $P$ is known (which is
  almost always), it is enough to write $P$.
  \item $\{v:\T ~|~ P(v)\land Q(v)\}$, abbreviated as $\T\cap P\cap Q$, or just $P\cap Q$. This extends
  to any number of conjuncts of the same form.
  \item $x : \T_2 \to \{v:\T_2 ~|~ R(x,v)\} \to \T_3$, abbreviated as $\big((\T_1\times\T_2)\cap R\big)\to\T_3$.
  Note that the first parameter to $R$ must be the preceding argument. This extends to quantifiers of
  any arity. Also note that the language does not define tuple types; hence there is no distinction
  between curried and uncurried function types.
\end{itemize}

The type refinement operators $\cap$ and $\times$ may be composed to create conjunctions of qualifiers,
as long as their argument sets are either disjoint or contained, but not overlapping;
for example, \[x:\{v:\T_1~|~P(v)\}\to \{v:\T_2~|~Q(v)\land R(x,v)\}\to\T_3\] can be written as
$\big((P\times Q)\cap R\big)\to\T_3$, but \[x:T_1\to y:\{v:\T_2~|~R(x,v)\} \to \{v:\T_3~|~R(y,v)\}\to\T_4\]
cannot be represented by this restricted fragment.

As with any refinement type system, we define the \newterm{shape} of a type $\T$ to be the raw type
obtained from it by removing all qualifiers.

\subsection{Operators}

\newcommand\applt{\textrm{{\scriptsize\,}\guillemotright{\scriptsize\,}}}

{\color{Gray}
\begin{itemize}
  \item Fixed point operator $\fix f$
  \item Slash operator $/$
  \item Cast operator $t :: \T$ inside expressions (and $t|_{\setlength{\fboxsep}{2pt}\fbox{}}$)
  \item Left application $x \applt f$
\end{itemize}
}

\subsection{Typing Rules}

We define a Bellmania program to be well-typed iff its \newterm{raw form}, obtained by replacing all types by
their shapes, is well-typed. This gives a simple characteristic of type safety without the need to
explictly write any new typing rules. It also means that for $f:\T_1\to\T_2$, $x:T_3$, then $f\,x:\T_2$ whenever
$\T_1$ and $\T_3$ have the same shape. This is much more permissive than the original Liquid Types,
and requires some explanation.\todo{covariance and coercion}

\subsection{Type Inference}

Base types are inferred normally as in a classical Hindley-Milner type system.
Qualifiers are also inferred by defining a type intersection operator $\sqcap$ that
takes two types of the same shape $\T_1$, $\T_2$ and returns a type with a conjunction of all the qualifiers
occuring in either $\T_1$ or $\T_2$. The operator is defined in terms of the corresponding liquid types.
\begin{itemize}
  \item If $\T_1=\{v:\T ~|~ \varphi_1\}$ and $\T_2=\{v:\T ~|~ \varphi_2\}$,
	\[\T_1\sqcap\T_2 ~=~ \{v:\T ~|~ \varphi_1\land\varphi_2\}\]
  \item If $\T_1=x:\S_1\to\S_2$, $\T_2=x:\S_3\to\S_4$ (named arguments are normalized so that $\T_1$ and $\T_2$ use the same names),
    \[\T_1\sqcap\T_2 ~=~ x:(\S_1\sqcap\S_3)\to(\S_2\sqcap\S_4)\]
\end{itemize}

We then define the \newterm{type refinement} steps for $e$ a sub-term:
\begin{itemize}
  \item If $e=e_1\,e_2$, where $\Gamma \vdash e:\T_0, e_1:\T_1, e_2:\T_2\to\S_2$,
    \[\Gamma ~\vdash~ e:\T_0\sqcap\S_2, e_1:\T_1\sqcap\T_2, e_2:(\T_0\to\T_1)\sqcap(\T_2\to\S_2)\]
  \item If $e=(v::\T)\mapsto e_1$, where $\Gamma\vdash e:\T_0\to\S_0$ and $\Gamma,v:\T\sqcap\T_0\vdash e_1:\T_1$,
    \[\Gamma ~\vdash~ e:(\T_0\to\S_0)\sqcap(\T\to\T_1)\]
    \[\Gamma,v:\T\sqcap\T_0 ~\vdash~ e_1:\T_1\sqcap\S_0\]
  \item If $e=v$ (a leaf) and $\Gamma,v:\T_1\vdash e:\T_0$,
    \[\Gamma,v:\T_1 ~\vdash~ e:\T_0\sqcap\T_1\]
  \item If $e=e_1/e_2$ and $\Gamma\vdash e:\T_0, e_1:\T_1, e_2:\T_2$,
    \[\Gamma ~\vdash~ e_1:T_1\sqcap\T_0, e_2:T_2\sqcap\T_0\]
\end{itemize}

These rules are applied continuously until a fixed point is reached.
The resulting type are eventually converted back to a canonical form that uses $\cap$ and $\times$.

Note that two syntactically identical terms in different sub-trees may be assigned
different types by this method. This is a desirable property, as (some) context information
gets encoded in the type that way.

\subsection{Primitives}

The standard library contains some common primitives:

\begin{itemize}
  \item $\R$, a type for real numbers; $\N$ for natural numbers; $\B$ for Boolean true/false.
  \item ${=} : \T\to\T\to\B$, always interpreted as equality.
  \item ${+}, {-} : \T\to\T\to\T$, polymorphic binary operators.
  \item ${<} : \T\to\T\to\B$, a polymorphic order relation.
  \item $\min, \max, \Sigma : (\T\to\S)\to\S$, reduction operators
    on ordered/unordered collections. The collection is represented by a mapping $f : \T\to\S$,
    so that e.g. \[\semp{\min f} = \min \{\semp{f}\,v \;|\; v\in\semp{A}, \semp{f}\,v\neq\bot\}\]
    The collections are expected to be finite.
\end{itemize}

\subsection{Example \hrulefill}

The specification of the Simplified Gap will be written as
%
\[\renewcommand\arraystretch{1.5}
  \begin{array}{@{}l@{}l@{}l@{}}
    \lspan3{w :: ((J\times J)\cap{<})\to\R} \\
    \lspan3{w' :: ((K\times K)\cap{<})\to\R} \\
    G ~=~ \fix \theta\,i\,j\mapsto{}
      & \lspan2{0\big|_{i=0\land j=0} ~\Big/~ w_{0j}\big|_{i=0} ~\Big/~ w_{i0}\Big|_{j=0} ~\Big/~} \\
      & \min~\langle~ & \min p\mapsto\theta_{pj}+w_{pi}, \\
      & & \min q\mapsto\theta_{iq}+w'_{qj} ~\rangle
  \end{array}\]

\medskip
We are using $f_{xy}$
as a more readable alternative typography for $f\,x\,y$,
where $f$ is a function symbol and $x$, $y$ are its arguments.

\medskip
\hrule
