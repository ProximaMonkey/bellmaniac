\documentclass{article}

\usepackage{amssymb,amsmath}

\newcommand\newterm[1]{{\it #1}}
\newcommand\R{\mathbb{R}}
\newcommand\N{\mathbb{N}}
\newcommand\B{\mathbb{B}}
\newcommand\T{\mathcal{T}}

\newcommand\semp[1]{[\![{#1}]\!]}
\newcommand\parto{\rightharpoonup}


\begin{document}

\begin{abstract}
We present a language for specifying DP algorithms, and a calculus that facilitates
gradual transformation of these specifications into efficient cache-oblivious
parallel implementations using the Divide and Conquer technique.
\end{abstract}

\section{The Language}

\subsection{Types}

Our language involves a type system and some specialized operators to manipulate
values. We define \newterm{raw types} to include:
\begin{itemize}
  \item The primitive types---$\N$ (natural numbers), $\R$ (real numbers), and $\B$ (Boolean truth values).
  \item User-defined uninterpreted scalar types. By convention, we use capital letters for those, e.g. $J$, $K$, $L$.
  \item Function types constructed using the type constructor $\to$. For $\T_1, \T_2$ types,
    $\T_1\to\T_2$ is a function type.
\end{itemize}


Function types have the semantics of partial functions. So the interpretation of $f :: J\to\R$, for example, would be
$\semp{f} : J\parto\R$. Since there are no tuple types, $(\T_1\times\T_2)\to\T_3$ is accepted as an alternative to
$\T_1\to\T_2\to\T_3$.

\medskip
\newterm{Predicates} are defined using $\B$ as a function range. So $P :: J\to\B$ defines a unary predicate
on $J$, and ${<} :: (J\times J)\to\B$ defines a binary relation.
Predicates can be used to annotate types, forming \newterm{refined types} similar to the ones
used in Liquid Types~\cite{PLDI08/Rondon}, but limited to the following subset:
\begin{itemize}
  \item $J\cap P$ is interpreted as $\{v:J\;|\;P(v)\}$. Since $J$ is the domain of $P$, it can be inferred;
    so in this case it is enough to just write $P$, when understood from the context that it denotes a
    type rather than an expression. E.g. $P\to\R$ is the same as $(J\cap P)\to\R$, both meaning
    $\{v:J\;|\;P(v)\}\to\R$.
  \item $((J\times J)\cap {<})\to\R$ is interpreted as $i:J\to\{v:J\;|\;i<v\}\to\R$. Due to the use of $\times$,
    binary and higher-arity predicates can only be used in argument types, i.e., on the left side of a $\to$
    constructor.
  \item It is possible to combine several predicates in type annotations, with the semantics of a conjunction.
    $J\cap P\cap Q$ (or just $P\cap Q$) means $\{v:J\;|\;P(v)\land Q(v)\}$.
    $((P\times J)\cap{<})\to\R$ means $i:\{v:J\;|\;P(v)\}\to\{v:J\;|\;i<v\}\to\R$.
    $((J\times P)\cap{<})\to\R$ means $i:J\to\{v:J\;|\;P(v)\land i<v\}\to\R$.
\end{itemize}

The $\to$ constructor is defined to be {\bf covariant} in {\bf both} arguments. So $K\to P$ is a subtype of $K\to J$
--- we write $K\to P <: K\to J$, and also $P\to K <: J\to K$. This is different from type semantics used in OO
languages.

Given a type $\T$, the raw type obtained from $\T$ by removing all predicate annotations
is called the \newterm{shape} of $\T$.


\subsection{Expressions}

The language is basically simply-typed lambda calculus, where abstraction terms are written as
$v::\T\mapsto e$, and application terms as $e_1\ e_2$. Infix notation is used as syntactic sugar
for symbols such as $+$, $<$, so that we can write $e_1 + e_2$ instead of ${+}\ e_1\ e_2$.
Thanks to type inference, type annotations may occasionally be omitted.

\subsection{Operators}

We will be using function types to represent $k$-dimensional arrays, in particular DP tables.
To support addressing of regions, we define two operators:

\begin{itemize}
  \item The \newterm{restrict} operator, $\big|_-$, coerces a function value to a subtype. 
    If $f::J\to K$, then $f\big|_P :: P\to K$
    with the semantics
    \[\semp{f\big|_P\ x} = \begin{cases}f\ x & \textrm{if}~P(x)\\ \bot & \textrm{o.w.}\end{cases}\]
    This is easily lifted to $k$-ary functions via $\times$ and $\cap$.
    As a special case, $\big|_-$ can be applied to scalar values (``nullary'' functions)
    by supplying a Boolean expression.
    \[\semp{y\big|_{i<j}} = \begin{cases}y & \textrm{if}~i<j \\ \bot & \textrm{o.w.}\end{cases}\]
  \item The \newterm{combine} operator, $/$. It operates on two functions with the same shape.
    \[\semp{f / g} = \overline{x}\mapsto\begin{cases}f\,\overline{x} & \textrm{if}~f\,\overline{x}\neq\bot \\ 
                                                     g\,\overline{x} & \textrm{o.w.}\end{cases}\]
    where $\overline{x}$ are $k$ fresh variables, $k$ being the arity of $f$ and $g$.
\end{itemize}

To express recursive computations, we employ fixed-point semantics.

\newcommand\fix{\mathrm{fix}\,}

\begin{itemize}
  \item For $f :: \T\to\T$, define $f^\omega :: \T\to\T$ such that for every $\theta :: \T$ there exists some $n\in\N$,
    \[f^\omega\,\theta = f^n\,\theta = f^{n+1}\,\theta\]
  \item For $f :: \T\to\T$, define $\fix f :: \T = f^\omega\,\bot$.\\
    If $\T$ is a function type, then $\bot$ is lifted to that type (e.g. $\bot :: X\to Y = x :: X \mapsto \bot :: Y$).
\end{itemize}


\section{Library of Primitives}

To express regular arithmetic and iteration, the ``prelude'' contains the following primitive
values:

\begin{itemize}
  \item ${+}, {-} :: \forall A.~A\times A\to A$ --- polymorphic binary operators.
  \item ${<} :: \forall A. ~A\times A\to\B$ --- a polymorphic order relation.
  \item $\min, \max, \Sigma :: \forall A,B.~ (A\to B)\to B$ --- reduction operators
    on ordered/unordered sequences. The sequence is represented by a function $f :: A\to B$,
    so that e.g. \[\semp{\min f} = \min_v \{f\,v \;|\; f\,v\neq\bot\}\]
    The sequences are expected to be finite.
  \item $\mathrm{nil} :: \N\to A, \mathrm{cons} :: A \to (\N\to A)\to(\N\to A)$ --- list constructors.
    Lists are represented as functions over $\N$. They are defined as
    \[\begin{array}{l}\mathrm{nil}=i\mapsto\bot \\
        \mathrm{cons}\,x\,xs = i\mapsto \big(x\big|_{i=0} ~\big/~ xs\,(i-1)\big)\end{array}\]
    Notice that, unlike with most functions, $\mathrm{cons}\,x\,xs\,i$ may be defined even if $x$ is not.
\end{itemize}


\section{Refinement Strategy}

\subsection{Tactics}

Each tactic defines a scheme of equalities that can be used for rewriting.
A valid application of a tactic is an instance of the scheme that is well-typed and logically valid
(as a simply-typed lambda calculus ``formula'').

\subsubsection{Slice}
\[f = f\big|_{X_1} \Big/ f\big|_{X_2} \Big/ ~\cdots~ \Big/ f\big|_{X_r}\]

This tactic breaks a function (array) into sub-regions. Clearly, the recombination expression is
valid when $\mathrm{supp}\,f \subseteq \bigcup X_i$, where $\mathrm{supp}\,f$ is the set of
argument values for which $f$ is defined.

\subsubsection{Stratify[/]}

\[
\begin{array}{l}
  \big(f_1 / \cdots / f_r\big)^\omega = \\
  \qquad
  \big(I_1 / \cdots I_{i-1} / f_i^\omega / I_{i+1} / \cdots / I_{r}\big)
  \cdot \big(f_1 / \cdots / f_{i-1} / I_i / f_{i+1} / \cdots / f_r\big)^\omega
\end{array}
\]

This tactic separates one element of a fixed-point computation out of a bunch
of $/$-separated slices. The $f_i$s should have a common shape 
$(\overline{X}\to A)\to \overline{X} \to A$,
where $\overline{X}$ may include multiple argument types, and their domains
should be disjoint by means of predicate annotations on their refined types.

In addition, $f_i$ must pertain that
\[\forall\theta.~ f_i\,\theta = f_i\,(g\,\theta)\]
%
where $g = f_1 / \cdots / f_{i-1} / I_i / f_{i+1} / \cdots / f_r$.
This is supposed to match our intuition that $f_i$ does not use (does not ``read'')
any of the values computed by any $f_j, j\neq i$, therefore it can be computed independently.

\bibliography{writeup}
\bibliographystyle{abbrv}

\end{document}
