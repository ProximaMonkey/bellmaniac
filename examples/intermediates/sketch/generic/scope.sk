/*
@Sort("J")  bit J(int i) { return 1; }
@Sort("J₀") @Leaf("0") bit J0(int i);
@Sort("J₁") @Leaf("1") bit J1(int i);
@Sort("K₀") bit K0(int i);
@Sort("K₁") bit K1(int i);
@Sort("K₂") bit K2(int i);
@Sort("K₃") bit K3(int i);
@Sort("L₀") bit L0(int i);
@Sort("L₁") bit L1(int i);
@Sort("L₂") bit L2(int i);
@Sort("L₃") bit L3(int i);
@Sort("L₄") bit L4(int i);
@Sort("L₅") bit L5(int i);

@Sort("I₀") bit I0(int i);
@Sort("I₁") bit I1(int i);

generator void Scope_facts(int n) {
  for (int p = 0 ; p < n ; ++p) {
    assume (J0(p) || J1(p));
    assume (I0(p) || I1(p));
    assume ((K0(p) || K1(p)) == J0(p)); 
    assume ((K2(p) || K3(p)) == J1(p)); 
    assume ((L0(p) || L1(p)) == K0(p)); 
    assume ((L2(p) || L3(p)) == K1(p)); 
    assume ((L4(p) || L5(p)) == K2(p)); 
    for (int q = 0 ; q < n ; ++q) {
      if (J0(p) && J1(q)) assume(p < q);
      if (I0(p) && I1(q)) assume(p < q);
      if (K0(p) && K1(q)) assume(p < q);
      if (K2(p) && K3(q)) assume(p < q);
      if (L0(p) && L1(q)) assume(p < q);
      if (L2(p) && L3(q)) assume(p < q);
      if (L4(p) && L5(q)) assume(p < q);
    }
  }
}

generator bit Scope_subsort(int t, int i) {
  if (t == 0) return false;
  else if (t == 1) return L0(i);
  else if (t == 2) return L1(i);
  else if (t == 3) return L2(i);
  else if (t == 4) return L3(i);
  else if (t == 5) return L4(i);
  else if (t == 6) return L5(i);
  else if (t == 7) return K0(i);
  else if (t == 8) return K1(i);
  else if (t == 9) return K2(i);
  else if (t == 10) return K3(i);
  else if (t == 11) return J0(i);
  else if (t == 12) return J1(i);
  else if (t == 13) return I0(i);
  else if (t == 14) return I1(i);
  else if (t == 15) return J(i);
  else assert(false);
}

generator bit Scope_1d(bit[4] t, int i) {
  return (t[0] && K0(i)) || (t[1] && K1(i)) || (t[2] && K2(i)) || (t[3] && K3(i));
}

generator bit Scope_leaf(int t, int i) {
  if      (t == 0) return K0(i);
  else if (t == 1) return K1(i);
  else if (t == 2) return K2(i);
  else if (t == 3) return K3(i);
  else assert(false);
}

generator bit Scope_leaf(int t, int i) {
  if      (t == 0) return J0(i);
  else if (t == 1) return J1(i);
  else if (t == 2) return false;
  else if (t == 3) return false;
  else assert(false);
}

int W = 4;
*/

/* this is needed because hole is multiplied by 4 */

pragma options "--bnd-mbits 6";

generator bit Scope_subsort_min(int i) {
    int _u = ??;
    bit[2] b = ??;
    minimize(_u*4+b[1]*2+b[0]);
    return Scope_subsort(_u, b, i);
}

bit Scope_2d(bit[W,3,W,3] t, bit lt, int i, int j) {
  bit acc = false;
  for (int p = 0; p < W; ++p)
    for (int ps = -1; ps < 2; ps++)
      for (int q = 0; q < W; ++q)
        for (int qs = -1; qs < 2; qs++)
          if (t[p,ps+1,q,qs+1])
            acc = acc || ( Scope_leaf(p, ps+i) && Scope_leaf(q, qs+j) );
  if (lt) acc = acc && (i < j);
  return acc;
}

/* left here as reference */
bit Scope_2d_easy(bit[W,W] t, bit lt, int i, int j) {
  bit acc = false;
  for (int p = 0; p < W; ++p)
    for (int q = 0; q < W; ++q)
      if (t[p,q])
        acc = acc || ( Scope_leaf(p, i) && Scope_leaf(q, j) );
  if (lt) acc = acc && (i < j);
  return acc;
}

generator int minimal(int i) { minimize(i); return i; }

generator bit minimal_1(bit b) { minimize(b); return b; }
generator bit[W] minimal_W(bit[W] a) { for (int i = 0; i < W; ++i) minimize(a[i]); return a; }
generator bit[W][4] minimal_WxW(bit[W][W] a) { 
  for (int i = 0; i < W; ++i) for (int j = 0; j < W; ++j) minimize(a[i][j]); return a; }
