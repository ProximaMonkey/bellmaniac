\section{Empirical Evaluation}

We implemented our technique and used it to generate cache-oblivious
divide-and-conquer implementations of three algorithms that were used as
benchmarks in \cite{IPDPS15/Tithi}, and a few others.

\begin{paragraph}{Gap problem.}
A generalized minimal edit distance problem. Given two input strings 
$\overline{x}=x_1\cdots x_m$ and $\overline{y}=y_1\cdots y_n$,
compute the cost of transforming $x$ into $y$ by any combination of the
following steps
\begin{itemize}
  \item Replacing $x_i$ with $y_j$, at cost $c_{ij}$.
  \item Deleting $x_{p+1}\cdots x_q$, at cost $\xw{pq}$.
  \item Inserting $y_{p+1}\cdots y_q$ in $\overline{x}$, at cost $\yw{pq}$.
\end{itemize}
\end{paragraph}

\begin{paragraph}{Parenthesis problem.} Compute
an optimal placements of parenthesis in a long chain of multiplication, e.g. of matrices, where the input is
are cost functions $x_i$ for accessing the $i$-th element and
$w_{ikj}$ for multiplying elements $[i,k)$ by elements $[k,j)$.
The corresponding recurrence is shown in \Cref{evaluation:paren spec}.
\end{paragraph}

\begin{paragraph}{Protein Accordion Folding problem.} A protein can be viewed
as a string $\mathcal{P}_{1..n}$ over an alphabet of amino acids. 
The protein folds itself in a way that minimizes potential energy.
Some of the acids are {\em hydrophobic}; minimization of the total hydrophobic
area exposed to water is a major driving force of the folding process.
One possible model is packing $\mathcal{P}$ in a two-dimensional square lattice
in a way that maximizes the number of pairs of hydrophobic elements,
where the shape of the fold is an {\em accordion}, alternating between going down and going
up.
\end{paragraph}

\medskip
We also exercised our system on a number of textbook problems:
the Longest Common Subsequence (LCS) problem, the Knapsack problem,
and the Bitonic Traveling Salesman problem.

\begin{figure}
\[
  \renewcommand\arraystretch{1.5}
  \begin{array}{@{}l@{}l}
    \lspan2{x :: J\to\R} \\
    \lspan2{w :: (J\times J\times J)\to\R} \\
    E ~=~ \fix \theta\,i\,j\mapsto{}
      & {\big[x_{ij}\big]_{i+1=j} ~\Big/~} \\
      & \min k\mapsto\theta_{ik}+\theta_{kj}+w_{ikj} \\
  \end{array}
\]
\caption{\label{evaluation:paren spec}
  Specifications for the Parenthesis Assignment DP problem.}
\end{figure}


The tactic application engine is implemented in Scala. We implemeted a prototype
IDE using HTML5 and AngularJS, which communicates with the engine by sending
and receiving program terms serialized as JSON. Our system supports using either
Z3 or CVC4 as the back-end SMT solver for discharging proof obligations required
for soundness proofs. Synthesis of recursive calls is done by translating the
program to Sketch, which employs CEGIS to find the correct assignment to parameters.
To argue for the feasibility of our system, we include
solver running time for the verification of the three most used tactics,
as well as time required for Sketch synthesis, in \Cref{evaluation:solving time}.
We consider an average delay of \textasciitilde 10 seconds to be reasonable, even for an interactive
environment such as Bellmania. 

The compiler for programs in Bellmania is implemented in 
python and generates C++ code with Intel Cilk constructs for parallelization.
Table~\ref{evaluation:cppruntimes} shows performance improvement for our 
auto-generated implementation (AUTO) on the state-of-the-art optimized parallel
loop implementation (LOOPDP) from~\cite{IPDPS15/Tithi}. It also compares AUTO with manually 
optimized recursive implementations CO\_Opt and COZ from~\cite{IPDPS15/Tithi}. 
Bellmania compiler automatically does \textit{copy optimization} 
as done in CO\_Opt and COZ. COZ also incorporates some low-level 
optimizations like using a Z-order layout of the array etc.,
which are out of scope for this paper. %pointer arithmetics for loop traversal? 
%Explicit vectorization of loops?
$N$ is the problem size and $B$ is the base case size for using loops 
instead of recursion. It can be seen from the table that our implementation 
performs close to the manually optimized code and can be optimized further by 
hand. Figure~\ref{fig:gap} depicts the performance of these implementations 
on one sample instance
as a function of problem size and shows the scalability of our technique. %ROHIT:scalability of what:the technique or the code?

\begin{table}
\centering
\begin{tabular}{|l|c|c|c|}
    \cline{2-4}
  \multicolumn{1}{c|}{} & \multicolumn{3}{c|}{\scriptsize Speedup w.r.t parallel LOOPDP on 6 cores}  \\
  \multicolumn{1}{c|}{} & \multicolumn{3}{c|}{\scriptsize   CPU (12 workers), N=16384, B=64}  \\
  \multicolumn{1}{c|}{} & \multicolumn{1}{c|}{~~~\sf CO\_Opt~~~} & \multicolumn{1}{c|}{~~~~\sf COZ~~~~} & \multicolumn{1}{c|}{\sf AUTO}  \\
  \hline
  {\bf Gap}  & 21x & 34x & 30x\\
  \hline
  {\bf Parenthesis}  & 32x & 50x & 46x\\
  \hline
  {\bf Protein} & 2.2x & 2.6x & 1.4x \\
  \hline
  %{\bf LCS} & 10x &  10x  &  10x \\
  %\hline
  {\bf Knapsack} & $-$ & $-$ & ?x\\
  \hline
  %{\bf Bitonic} & & 2 & \\
  %\hline
\end{tabular}
\caption{\label{evaluation:cppruntimes}
  Performance of different C++ implementations}
\end{table}


\begin{table}
\centering
\renewcommand\a{({\it i})}    % relax! it's only for this figure
\renewcommand\b{({\it ii})}
\renewcommand\c{({\it iii})}
\begin{tabular}{|l|r|rrr|r@{\quad}|}
  \cline{2-6}
  \multicolumn{1}{c|}{} &    & \multicolumn{4}{c|}{\small Average solving time ({\it s})}  \\
  \multicolumn{1}{c|}{} &    & \multicolumn{3}{c|}{\small Verification} & \multicolumn{1}{@{\,}c@{\,}|}{\small Synthesis} \\
  \multicolumn{1}{c|}{} & \# & \multicolumn{1}{c|}{~\sf Slice~} & \multicolumn{1}{c|}{\sf Stratify} & \multicolumn{1}{c|}{\sf Synth} & \multicolumn{1}{c|}{Sketch} \\
  \hline
  {\bf Gap                 }  &  3  &  1.5  &  6.4   &   0.2  &  8     \\
  \hline
  {\bf Paren               }  &  3  &  0.8  &  16.5   &   0.8  &  11.2     \\
  \hline
  {\bf Accordion           }  &  4  &  0.6  &  3.8   &   0.4  &  6.1     \\
  \hline
  {\bf LCS                 }  &  1  &  0.2  &  1.5   &   0.4  &  3.1     \\
  \hline
  {\bf Knapsack            }  &  2  &  0.3  &  1.6   &   0.4  &  4.6     \\
  \hline
  {\bf Bitonic             }  &  3  &  0.7  &  1.9   &   0.7  &  6.4     \\
  \hline
\end{tabular}
\caption{\label{evaluation:solving time}
  Average proof search time for proof obligations and synthesis
  time}
\end{table}



\begin{figure}
\input{gfx/charts}
\caption{\label{fig:gap} Performance comparison for parallelized implementations for Gap problem on 6-core Intel i7 CPU}
\end{figure}