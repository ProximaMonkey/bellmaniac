\documentclass[pldi,preprint]{sigplanconf-pldi16}

\usepackage{amsmath,amssymb,amsopn,amsthm}
\usepackage[T1]{fontenc}
\usepackage{algorithmicx,algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{multirow}
\usepackage{cleveref}
\usepackage{graphicx}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{verbatim}
\usepackage{relsize}
\usepackage{ifluatex}
%\usepackage{stfloats}

\usepackage{tikz}
\usetikzlibrary{fit,positioning,patterns,shapes,shapes.multipart}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\pgfplotsset{compat=1.12} 

\newcommand\newterm[1]{{\it #1}}
\newcommand\R{\mathbb{R}}
\newcommand\N{\mathbb{N}}
\newcommand\B{\mathbb{B}}
\newcommand\T{\mathcal{T}}
\renewcommand\S{\mathcal{S}}

\newcommand\lspan[2]{\multicolumn{#1}{@{}l}{#2}}
\newcommand\cspan[2]{\multicolumn{#1}{@{}c}{#2}}

\makeatletter
\newcommand{\LeftEqNo}{\let\veqno\@@leqno}
\makeatother

\newcommand\limplies{\rightarrow}
\newcommand\liff{\leftrightarrow}

\newcommand\exampleTitle{
\bigskip\noindent
\begin{tikzpicture}
  \draw (0,0) -- (5mm,0)
    node(e)[draw,rectangle,rounded corners=.7em,right] {\bf Example};
  \draw (e) -- (\columnwidth,0);
\end{tikzpicture}%
\medskip%
}

% author comment macros
\newcommand\authornote[3]{{\color{#2} \footnote{\color{#2} {#1}: {#3}}}}
\newcommand\todo[1]{{\color{NavyBlue} \footnote{\color{NavyBlue} TODO: {#1}}}}

\newcommand\asolar[1]{\authornote{AS}{BrickRed}{#1}}  % Armando
\newcommand\cel[1]{\authornote{CL}{OliveGreen}{#1}}   % Charles
\newcommand\rch[1]{\authornote{RC}{RoyalPurple}{#1}}  % Rezaul
\newcommand\pga[1]{\authornote{PG}{RawSienna}{#1}}    % Pramod
\newcommand\coa[1]{\authornote{SI}{NavyBlue}{#1}}     % Shachar

% Armando hack
\newif\ifarmando

\ifluatex
\directlua{
    if not (arg == nil) then
      for i,v in pairs(arg) do
        if (v == "armando") then
          tex.print("\string\\armandotrue")
        end
      end
    end
  }
\fi

\include{macros}

\begin{document}


\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

%\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country} 
%\copyrightyear{20yy} 
%\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
%\doi{nnnnnnn.nnnnnnn}

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.

%\title{Bellmania: Deriving Implementations from Specifications by Transformation}
%\title{Solver-Aided Transformational Synthesis of Divide-and-Conquer Dynamic Programming Algorithms}
\title{Deriving Divide-and-Conquer Dynamic Programming Algorithms Using 
  Solver-Aided Transformations}

%\authorinfo{Shachar Itzhaky}
%           {MIT CSAIL}
%           {shachari@mit.edu}
\authorinfo{Double-blind submission}
           {}
           {}

\maketitle

\begin{abstract}
We introduce \newterm{solver-aided tactics} as a mechanism for transforming
computational terms 
in the interest of deriving better, more efficient
implementations. 
Solver-aided tactics allow us to combine deductive and constraint-based synthesis to generate provably correct efficient implementations from a very high-level specification of an algorithm by chaining together a small number of high-level transformation steps. Our solver-aided tactics also leverage a type system, which incorporates predicate abstraction to associate semantic information with program terms, to guide transformations and provide enough context for automated proofs. 


In this paper, we develop the technique in the context of a system called Bellmania that uses solver-aided tactics to derive parallel divide-and-conquer implementations of dynamic programming algorithms that have better locality and are significantly more efficient than traditional loop-based implementations. Bellmania includes a high-level language for specifying dynamic programming algorithms and a calculus that facilitates gradual transformation of these specifications into efficient implementations. In particular, it provides solver-aided tactics that formalize the divide-and-conquer technique and a visualization interface to help users to interactively guide the transformation process. 
We have used the system to generate provably correct implementations of several algorithms including some important algorithms from computational biology, and show that the performance is comparable to that of the best manually optimized code.
\end{abstract}

\category{D.1.2}{Programming Techniques}{Automatic Programming}
% \category{I.2.2}{Artificial Intelligence}{Automatic Programming}[Program synthesis]
%
\keywords
Synthesis; Dynamic Programming 

\input{01-intro}
\input{02-overview}
\input{03-lang}
\input{04-tactics}
\input{05-automated}
\input{06-codegen}
\input{06-evaluation}
\input{07-related}
\input{08-conc}

\appendix

\input{A-more-tactics}

\bibliographystyle{abbrvnat}
\bibliography{pldi2016} % embed contents of pldi2016.bbl for source submission


\end{document}
